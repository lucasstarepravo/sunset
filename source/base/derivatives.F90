module derivatives
  !! This module contains routines to calculate various derivatives
  !! using weightings generated by LABFM. It should be the only
  !! module in the code which performs loops over neighbours during
  !! the simulation.
  !! N.B. Reformulated with ij_sums to improve efficiency. Only one + and *
  !! used within inner loops.
  use kind_parameters
  use common_parameter
  use common_2d
  use omp_lib
  implicit none

contains
  subroutine calc_gradient(phi,gradphi)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:),intent(in) :: phi
    real(rkind),dimension(:,:),intent(inout) :: gradphi
    integer :: i,j,k
    real(rkind),dimension(dims) :: gradtmp
    real(rkind) :: gradztmp
     
    
    !$OMP PARALLEL DO PRIVATE(j,k,gradtmp)
    do i=1,npfb
       gradtmp=zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          gradtmp(1:2) = gradtmp(1:2) + phi(j)*ij_w_grad(:,k,i)
       end do
       gradphi(i,1:2) = gradtmp(1:2) - phi(i)*ij_w_grad_sum(:,i)                           
    end do
    !$OMP END PARALLEL DO
    
    
#ifdef dim3       
    !! Finite differences along z
    !$OMP PARALLEL DO PRIVATE(j,k,gradztmp)
    do i=1,npfb
       gradztmp=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          gradztmp = gradztmp + phi(j)*ij_fd_grad(k)
       end do
       gradphi(i,3) = gradztmp
    end do
    !$OMP END PARALLEL DO
#else
    !! Or set to zero if 2D simulations
    gradphi(:,3) = zero    
#endif    

    return
  end subroutine calc_gradient
!! ------------------------------------------------------------------------------------------------
  subroutine calc_laplacian(phi,lapphi)
    !! Calculate the Laplacian of a scalar phi
    real(rkind),dimension(:),intent(in) :: phi
    real(rkind),dimension(:),intent(inout) :: lapphi
    integer i,j,k
    real(rkind) :: lap_tmp

    !$OMP PARALLEL DO PRIVATE(j,k,lap_tmp)
    do i=1,npfb
       lap_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          lap_tmp = lap_tmp + phi(j)*(ij_w_grad2(1,k,i)+ij_w_grad2(3,k,i))
       end do
       lapphi(i) = lap_tmp - phi(i)*(ij_w_grad2_sum(1,i)+ij_w_grad2_sum(3,i)) 
    end do
    !$OMP END PARALLEL DO
    
#ifdef dim3
    !! Finite differences along z    
    !$OMP PARALLEL DO PRIVATE(j,k,lap_tmp)
    do i=1,npfb
       lap_tmp=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          lap_tmp = lap_tmp + phi(j)*ij_fd_grad2(k)
       end do
       lapphi(i) = lapphi(i) + lap_tmp
    end do
    !$OMP END PARALLEL DO
#endif        

  end subroutine calc_laplacian
!! ------------------------------------------------------------------------------------------------
  subroutine calc_divergence(phi1,phi2,phi3,divphi)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:),intent(in) :: phi1,phi2,phi3
    real(rkind),dimension(:),intent(inout) :: divphi
    integer :: i,j,k
    real(rkind),dimension(dims) :: fji
    real(rkind) :: divtmp
    
    !$OMP PARALLEL DO PRIVATE(j,k,fji,divtmp)
    do i=1,npfb
       divtmp=zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          fji(1) = phi1(j);fji(2) = phi2(j)
          divtmp = divtmp + dot_product(fji,ij_w_grad(:,k,i))
       end do
       divphi(i) = divtmp - dot_product((/phi1(i),phi2(i)/),ij_w_grad_sum(:,i))
    end do
    !$OMP END PARALLEL DO
    
#ifdef dim3       
    !! Finite differences along z
    !$OMP PARALLEL DO PRIVATE(j,k,divtmp)
    do i=1,npfb
       divtmp=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          divtmp = divtmp + phi3(j)*ij_fd_grad(k)
       end do
       divphi(i) = divphi(i) + divtmp
    end do
    !$OMP END PARALLEL DO  
#endif     
    
    return
  end subroutine calc_divergence
!! ------------------------------------------------------------------------------------------------  
#ifdef dim3
  subroutine calc_grad2(phi,gradphi,grad2)
#else
  subroutine calc_grad2(phi,grad2)
#endif  
    !! Calculate the 2nd derivatives of a scalar phi
    !! If three-dimensional, d/dz^2 is straight FD, and d/dxdz, d/dydz are FD (in Z) derivatives
    !! of the labfm derivative in the X-Y plane
    real(rkind),dimension(:),intent(in) :: phi
#ifdef dim3
    real(rkind),dimension(:,:),intent(in) :: gradphi
    real(rkind) :: gradxz,gradyz
#endif        
    real(rkind),dimension(:,:),intent(inout) :: grad2
    real(rkind),dimension(3) :: d2_tmp
    real(rkind) :: grad2ztmp
    integer i,j,k

    !$OMP PARALLEL DO PRIVATE(j,k,d2_tmp)
    do i=1,npfb
       d2_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          d2_tmp(:) = d2_tmp(:) + phi(j)*ij_w_grad2(:,k,i)
       end do
       grad2(i,1:3) = d2_tmp(:) - phi(i)*ij_w_grad2_sum(:,i)                                                             
    end do
    !$OMP END PARALLEL DO

#ifdef dim3    
    !$OMP PARALLEL DO PRIVATE(j,k,grad2ztmp,gradxz,gradyz)
    do i=1,npfb
       grad2ztmp=zero
       gradxz = zero;gradyz=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          !! Direct ZZ derivative
          grad2ztmp = grad2ztmp + phi(j)*ij_fd_grad2(k)

          !! Cross derivatives
          gradxz = gradxz + gradphi(j,1)*ij_fd_grad(k)
          gradyz = gradyz + gradphi(j,2)*ij_fd_grad(k)          
       end do
       grad2(i,5) = grad2ztmp
       grad2(i,4) = gradyz      
       grad2(i,6) = gradxz
    end do
    !$OMP END PARALLEL DO 
#else
    grad2(:,4:6) = zero
#endif    

  end subroutine calc_grad2
!! ------------------------------------------------------------------------------------------------
  subroutine calc_grad2tang(phi,g2tphi)
    !! Calculate the Laplacian of a scalar phi
    real(rkind),dimension(:),intent(in) :: phi
    real(rkind),dimension(:),intent(inout) :: g2tphi
    integer i,j,k,ii
    real(rkind) :: g2t_tmp

    !$OMP PARALLEL DO PRIVATE(i,j,k,g2t_tmp)
    do ii=1,nb
       i=boundary_list(ii)
       g2t_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          g2t_tmp = g2t_tmp + phi(j)*ij_w_grad2(3,k,i)
       end do
       g2tphi(ii) = g2t_tmp - phi(i)*ij_w_grad2_sum(3,i)
    end do
    !$OMP END PARALLEL DO

  end subroutine calc_grad2tang  
!! ------------------------------------------------------------------------------------------------  
  subroutine calc_filtered_var(phi)
    !! Calculate the hyperviscosity filtered phi
    real(rkind),dimension(:),intent(inout) :: phi
    real(rkind),dimension(:),allocatable :: filtphi
    integer i,j,k
    real(rkind) :: hyp_tmp

    !! Allocate temporary store
    allocate(filtphi(npfb))
    
    !! Calculate filtered phi
    !$OMP PARALLEL DO PRIVATE(j,k,hyp_tmp)
    do i=1,npfb
       hyp_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          hyp_tmp = hyp_tmp + phi(j)*ij_w_hyp(k,i)
       end do
       filtphi(i) = phi(i) + filter_coeff(i)*(hyp_tmp - phi(i)*ij_w_hyp_sum(i))
    end do
    !$OMP END PARALLEL DO

    !! Pass filtered phi back to phi
    phi(1:npfb)=filtphi(1:npfb)

#ifdef dim3   

    !! Note in FD schemes, we have to do the coordinates sequentially, so filtering in Z is done
    !! to the X-Y filtered field...
    !$OMP PARALLEL DO PRIVATE(j,k,hyp_tmp)
    do i=1,npfb
       hyp_tmp=zero
       filtphi(i) = phi(i)
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          hyp_tmp = hyp_tmp + phi(j)*ij_fd_hyp(k)
       end do
       filtphi(i) = filtphi(i) + hyp_tmp
    end do
    !$OMP END PARALLEL DO 
    
    !! Pass filtered phi back to phi    
    phi(1:npfb)=filtphi(1:npfb)    
#endif

    deallocate(filtphi)

    return
  end subroutine calc_filtered_var   
!! ------------------------------------------------------------------------------------------------     
end module derivatives
