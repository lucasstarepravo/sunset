module derivatives
  !! ----------------------------------------------------------------------------------------------
  !! SUNSET CODE: Scalable Unstructured Node-SET code for DNS.
  !! 
  !! Author             |Date             |Contributions
  !! --------------------------------------------------------------------------
  !! JRCK               |2019 onwards     |Main developer                     
  !!
  !! ----------------------------------------------------------------------------------------------
  !! This module contains routines to calculate various derivatives
  !! using weightings generated by LABFM. It should be the only
  !! module in the code which performs loops over neighbours during
  !! the simulation.
  !! N.B. Reformulated with ij_sums to improve efficiency. Only one + and *
  !! used within inner loops.
  use kind_parameters
  use common_parameter
  use common_vars
  use omp_lib
  implicit none

contains
!! ------------------------------------------------------------------------------------------------
  subroutine calc_gradient(phi,gradphi)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:),intent(in) :: phi
    real(rkind),dimension(:,:),intent(inout) :: gradphi
    integer :: i,j,k
    real(rkind),dimension(dims) :: gradtmp
    real(rkind) :: gradztmp

    segment_tstart = omp_get_wtime()     
    
    !$OMP PARALLEL DO PRIVATE(j,k,gradtmp)
    do i=1,npfb
       gradtmp=zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          gradtmp(1:2) = gradtmp(1:2) + phi(j)*ij_w_grad(:,k,i)
       end do
       gradphi(i,1:2) = gradtmp(1:2) - phi(i)*ij_w_grad_sum(:,i)                           
    end do
    !$OMP END PARALLEL DO
    
    
#ifdef dim3       
    !! Finite differences along z
    !$OMP PARALLEL DO PRIVATE(j,k,gradztmp)
    do i=1,npfb
       gradztmp=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          gradztmp = gradztmp + phi(j)*ij_fd_grad(k)
       end do
       gradphi(i,3) = gradztmp
    end do
    !$OMP END PARALLEL DO
#else
    !! Or set to zero if 2D simulations
    gradphi(:,3) = zero    
#endif    


    !! Profiling
    segment_tend = omp_get_wtime()
    segment_time_local(4) = segment_time_local(4) + segment_tend - segment_tstart

    return
  end subroutine calc_gradient
!! ------------------------------------------------------------------------------------------------
  subroutine calc_laplacian(phi,lapphi)
    !! Calculate the Laplacian of a scalar phi
    real(rkind),dimension(:),intent(in) :: phi
    real(rkind),dimension(:),intent(inout) :: lapphi
    integer i,j,k
    real(rkind) :: lap_tmp
    
    segment_tstart = omp_get_wtime()         

    !$OMP PARALLEL DO PRIVATE(j,k,lap_tmp)
    do i=1,npfb
       lap_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          lap_tmp = lap_tmp + phi(j)*ij_w_lap(k,i)
       end do
       lapphi(i) = lap_tmp - phi(i)*ij_w_lap_sum(i)
    end do
    !$OMP END PARALLEL DO
    
#ifdef dim3
    !! Finite differences along z    
    !$OMP PARALLEL DO PRIVATE(j,k,lap_tmp)
    do i=1,npfb
       lap_tmp=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          lap_tmp = lap_tmp + phi(j)*ij_fd_grad2(k)
       end do
       lapphi(i) = lapphi(i) + lap_tmp
    end do
    !$OMP END PARALLEL DO
#endif        

    !! Profiling
    segment_tend = omp_get_wtime()
    segment_time_local(5) = segment_time_local(5) + segment_tend - segment_tstart
    return
  end subroutine calc_laplacian
!! ------------------------------------------------------------------------------------------------
  subroutine calc_divergence(phi1,phi2,phi3,divphi)
    !! Calculate the gradient of scalar phi.
    real(rkind),dimension(:),intent(in) :: phi1,phi2,phi3
    real(rkind),dimension(:),intent(inout) :: divphi
    integer :: i,j,k
    real(rkind),dimension(2) :: fji
    real(rkind) :: divtmp
    
    segment_tstart = omp_get_wtime()         
    
    !$OMP PARALLEL DO PRIVATE(j,k,fji,divtmp)
    do i=1,npfb
       divtmp=zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          fji(1) = phi1(j);fji(2) = phi2(j)
          divtmp = divtmp + dot_product(fji,ij_w_grad(:,k,i))
       end do
       divphi(i) = divtmp - dot_product((/phi1(i),phi2(i)/),ij_w_grad_sum(:,i))
    end do
    !$OMP END PARALLEL DO
    
#ifdef dim3       
    !! Finite differences along z
    !$OMP PARALLEL DO PRIVATE(j,k,divtmp)
    do i=1,npfb
       divtmp=zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          divtmp = divtmp + phi3(j)*ij_fd_grad(k)
       end do
       divphi(i) = divphi(i) + divtmp
    end do
    !$OMP END PARALLEL DO  
#endif     
    
    !! Profiling
    segment_tend = omp_get_wtime()
    segment_time_local(6) = segment_time_local(6) + segment_tend - segment_tstart   
    return
  end subroutine calc_divergence
!! ------------------------------------------------------------------------------------------------  
  subroutine calc_grad2bound(phi,g2phi)
    !! Calculate the second derivatives of properties on boundary nodes ONLY
    real(rkind),dimension(:),intent(in) :: phi
    real(rkind),dimension(:,:),intent(inout) :: g2phi
    integer i,j,k,ii
    real(rkind),dimension(dims) :: g2_tmp

    segment_tstart = omp_get_wtime()         

    !$OMP PARALLEL DO PRIVATE(i,j,k,g2_tmp)
    do ii=1,nb
       i=boundary_list(ii)
       g2_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          g2_tmp(1) = g2_tmp(1) + phi(j)*ij_wb_grad2(1,k,ii)
          g2_tmp(2) = g2_tmp(2) + phi(j)*ij_wb_grad2(2,k,ii)
       end do
       g2phi(ii,1) = g2_tmp(1) - phi(i)*ij_wb_grad2_sum(1,ii)
       g2phi(ii,2) = g2_tmp(2) - phi(i)*ij_wb_grad2_sum(2,ii)       
    end do
    !$OMP END PARALLEL DO

#ifdef dim3    
    !$OMP PARALLEL DO PRIVATE(i,j,k,g2_tmp)
    do ii=1,nb
       i=boundary_list(ii)
       g2_tmp = zero
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          !! Direct ZZ derivative
          g2_tmp(3) = g2_tmp(3) + phi(j)*ij_fd_grad2(k)       
       end do
       g2phi(ii,3) = g2_tmp(3)
    end do
    !$OMP END PARALLEL DO 
#else
    g2phi(:,3) = zero
#endif      

    !! Profiling
    segment_tend = omp_get_wtime()
    segment_time_local(7) = segment_time_local(7) + segment_tend - segment_tstart

    return
  end subroutine calc_grad2bound
!! ------------------------------------------------------------------------------------------------  
  subroutine calc_filtered_var(phi)
    !! Calculate the hyperviscosity filtered phi
    real(rkind),dimension(:),intent(inout) :: phi
    real(rkind),dimension(:),allocatable :: filtphi
    integer i,j,k
    real(rkind) :: hyp_tmp

    !! Allocate temporary store
    allocate(filtphi(npfb))
    
    !! Calculate filtered phi
    !$OMP PARALLEL DO PRIVATE(j,k,hyp_tmp)
    do i=1,npfb
       hyp_tmp = zero
       do k=1,ij_count(i)
          j = ij_link(k,i) 
          hyp_tmp = hyp_tmp + phi(j)*ij_w_hyp(k,i)
       end do
       filtphi(i) = phi(i) + filter_coeff(i)*(hyp_tmp - phi(i)*ij_w_hyp_sum(i))
    end do
    !$OMP END PARALLEL DO

    !! Pass filtered phi back to phi
    phi(1:npfb)=filtphi(1:npfb)

#ifdef dim3   

    !! Note in FD schemes, we have to do the coordinates sequentially, so filtering in Z is done
    !! to the X-Y filtered field...
    !$OMP PARALLEL DO PRIVATE(j,k,hyp_tmp)
    do i=1,npfb
       hyp_tmp=zero
       filtphi(i) = phi(i)
       do k=1,ij_count_fd
          j = ij_link_fd(k,i) 
          hyp_tmp = hyp_tmp + phi(j)*ij_fd_hyp(k)
       end do
       filtphi(i) = filtphi(i) + hyp_tmp
    end do
    !$OMP END PARALLEL DO 
    
    !! Pass filtered phi back to phi    
    phi(1:npfb)=filtphi(1:npfb)    
#endif

    deallocate(filtphi)

    return
  end subroutine calc_filtered_var   
!! ------------------------------------------------------------------------------------------------     
end module derivatives
